select * from mydustselect partnum, price from mydustselect*, quantity*price as InvValue from mydustselect * from mydustwhere quantity < 25order by 4 descselect* from mydustwhere descrip = 'muffler'select* from mydustwhere descrip like 'm%'select * from mydust where price >= 25 and price <= 75select * from mydust where price between 25 and 75--between is inclusive of valuesselect*from mydust where automake = 'vw' or automake = 'ford'select*from mydust where automake in ('vw','ford')--same as previousselect*from mydust where automake = 'vw' or automake = 'ford'select*from mydust where not (automake = 'vw' or automake = 'ford')--NOT has precedence over ORselect quantity from mydustselect sum(quantity) as TotalQuantity from mydustselect descrip, sum(quantity) as TotalQuantity from mydustgroup by descripselect* from employeeselect count(*) from employeeselect count(add2)from employeeselect descrip, sum(quantity) as TotalQuantity from mydustgroup by descrip having sum(quantity) > 300select descrip, sum(quantity) as TotalQuantityfrom mydustwhere descrip = 'muffler'--line item level at the table levelgroup by descriphaving sum(quantity) > 300select avg(price)from mydustselect round(avg(price),2)from mydustselect convert(numeric(5,2)avg(price)) from mydustselect distinct descrip from mydust--produces non-repeating values/* Exercise 1*/Select * from atrans--question1order by invoiceSelect sales from atrans--question2where cusid = 'CCW1'Select * from atrans--question3order by salesid,mfgid--ascending sort by defaultSelect * from atrans--question4where salesid = 'TJ' and mfgid = 'FFF'order by invoice--multi-Table Joins page 10select * from salesrepselect * from sales--Inner Join or equal join, where they match upSelect Salesrep.Empnum, FName, AmountFROM Salesrep    INNER JOIN Sales ON Salesrep.Empnum = Sales.EmpnumSelect Salesrep.Empnum, FName, AmountFROM Salesrep    INNER JOIN Sales ON Salesrep.Empnum = Sales.Empnumwhere amount > 20Select R.Empnum, FName, AmountFROM Salesrep RINNER JOIN Sales S ON R.Empnum = S.Empnum--left outer joinselect * from salesrep--leftselect * from sales--rightSelect salesrep.empnum, fname, amountFROM salesrep LEFT OUTER JOIN Sales ON salesrep.empnum = sales.empnum--right outer joinSelect salesrep.empnum, fname, amountFROM salesrep RIGHT OUTER JOIN Sales ON salesrep.empnum = sales.empnum--full outer joinSelect salesrep.empnum, fname, amountFROM salesrep FULL OUTER JOIN Sales ON salesrep.empnum = sales.empnumSelect sales.empnum, fname, amountFROM salesrep FULL OUTER JOIN Sales ON salesrep.empnum = sales.empnumSelect coalesce (sales.empnum, sales.empnum)as empnum, fname, amountFROM salesrep FULL OUTER JOIN Sales ON salesrep.empnum = sales.empnum--creating cross join or cartesian productselect salesrep.empnum, fname, amount--a full data dump that lists everybody outfrom salesrep cross join sales--Exercise 2select * FROM Employeeselect *FROM DependentsSelect Employee.lastname, Employee.firstname, Dependents.depname, Dependents.birthdayFROM EmployeeINNER JOIN Dependents ON employee.id = dependents.empidSelect Employee.lastname, Employee.firstname, Dependents.depname, Dependents.birthdayFROM EmployeeINNER JOIN Dependents ON employee.id = dependents.empidWHERE Employee.lastname = 'Berty' AND Employee.firstname = 'Kelley'Select Employee.lastname, Employee.firstname, Dependents.depname, Dependents.birthdayFROM EmployeeINNER JOIN Dependents ON employee.id = dependents.empidWHERE Employee.city = 'Oakland'Select Employee.lastname, Employee.firstname, Dependents.depname, Dependents.birthdayFROM EmployeeLeft Outer Join Dependents ON employee.id = dependents.empid--Exercise 3Select * FROM EmployeeSelect * FROM AbsentSelect Employee.lastname, Employee.firstname, absent.absdate, absent.excused--Q1FROM EmployeeINNER Join Absent on employee.id = absent.idSelect Employee.lastname, Employee.firstname, absent.absdate, absent.excused--Q2FROM EmployeeLeft Join Absent on employee.id = absent.idWhere absent.excused = 'N'Select Employee.lastname, Employee.firstname, absent.absdate, absent.excused--Q3FROM EmployeeLeft Join Absent on employee.id = absent.idWhere Employee.lastname = 'Smith' AND Employee.firstname = 'Thomas'Select Employee.lastname, Employee.firstname, absent.absdate, absent.excused--Q4FROM EmployeeLEFT OUTER Join Absent on employee.id = absent.id--Exercise 4Select *From MyDustSelect *From MysalesSelect mysales.partnum, mydust.descrip, mysales.qty_sold--question1 From mysalesInner Join mydust on mysales.partnum=mydust.partnumSelect mysales.partnum, mydust.automake, mydust.descrip, mysales.qty_sold, mysales.saledate--question2 From mysalesInner Join mydust on mysales.partnum=mydust.partnumWhere mydust.descrip = 'muffler'Select mysales.partnum, mydust.automake, mydust.descrip, mysales.qty_sold--question3 From mysalesInner Join mydust on mysales.partnum=mydust.partnumWhere automake IN ('FORD', 'CHRY')Select descrip, automake, qty_sold, customer--extraFrom mysales  inner join mydust on mysales.partnum = mydust.partnumwhere customer = 'Joe''s Garage'--use double single quoteswhere customer = 'Joe_s Garage'--or use wildcard _Select descrip, SUM(Qty_sold) As Total_SoldFrom Mydust   Inner Join MySales on MyDust.Partnum = mysales.PartnumGroup By Descrip --bring in non-aggregate valueSelect descrip, SUM(Qty_sold) As Total_SoldFrom Mydust   Inner Join MySales on MyDust.Partnum = mysales.PartnumGroup By Descrip --bring in non-aggregate valueHaving sum(qty_sold) > 9Select Firstname, Lastname, SUM(Hours) AS AbshoursFrom Employee   Left Outer Join Absent ON Employee.ID = Absent.IDGroup BY Lastname, Firstname--page 21 joining multiple tablesselect * from seminarselect * from courseselect * from registerselect * from studentsSelect course.progcode, seminar.title, register.ssnfrom seminarinner join course on seminar.semcode = course.semcodeinner join register on course.progcode = register.progcodeSelect course.progcode, seminar.title, register.ssnfrom seminarinner join course on seminar.semcode = course.semcodeinner join register on course.progcode = register.progcodeWhere Register.progcode = 'A1002'Select course.progcode, seminar.title, Count(*) AS Total_Enrollmentfrom seminarinner join course on seminar.semcode = course.semcodeinner join register on course.progcode = register.progcodeGroup by Course.Progcode, Title--these are non-aggregatesSelect course.progcode, seminar.title, Count(*) AS Total_Enrollmentfrom seminarinner join course on seminar.semcode = course.semcodeleft outer join register on course.progcode = register.progcodeGroup by Course.Progcode, TitleSelect course.progcode, seminar.title, Count(register.progcode) AS Total_Enrollmentfrom seminarinner join course on seminar.semcode = course.semcodeleft outer join register on course.progcode = register.progcodeGroup by Course.Progcode, Titleselect * into register2 from register--select all fields into make table register2order by 2delete from register2 where progcode = 'a1007'--gets rid of person enrolled in class 7select *from register2Select register.ssn, firstname, lastname, course.progcode, titlefrom seminarinner join course on seminar.semcode = course.semcodeinner join register on course.progcode = register.progcodeInner join students ON Register.Ssn = Students.SsnWhere Course.Progcode = 'A1008'Select firstname, lastname, course.progcode, titlefrom seminarinner join course on seminar.semcode = course.semcodeinner join register on course.progcode = register.progcodeInner join students ON Register.Ssn = Students.SsnWhere Course.Progcode = 'A1008'--Create Viewscreate view Roster as  --gives you an object roster which is your virtual tableSelect firstname, lastname, course.progcode, titlefrom seminarinner join course on seminar.semcode = course.semcodeinner join register on course.progcode = register.progcodeInner join students ON Register.Ssn = Students.Ssnselect * from roster --a view called rostersp_helptext rostersp_help rosterSelect * FROM RosterWhere Progcode = 'A1002'Create VIEW EmpAddress AS SELECT Id, Lastname, Firstname, Add1, Add2, City, Statecode, Zip, Phone    From Employeeselect * from empaddress--the viewselect * from employee--the table with all the fields in itupdate empaddress set phone = '314-966-0132'where id = 'A0004'Create view PartsList(Partnum, Description, Automake, Quantity, Price)as select * from mydustSelect * from partslistALTER VIEW EmpAddress AS--to change a view SELECT Id, SSN, Lastname, Firstname, Add1, Add2, City, Statecode, Zip, Phone    From Employeeselect * from empaddressdrop view empaddress--to delete a view--Exercise 4Select *From BurgersCreate view nopay(Week, Empname, Hours)--question1as select Week, Empname, Hours from BurgersSelect Empname, Hours from nopaySelect Empname,SUM(Hours)--question2 From nopayWhere nopay.Empname = 'Ann'Group by EmpnameCreate view nopay3 as --question3Select Week, Empname, Hours*Payrate AS totalpayFrom Burgersselect *from nopay3select *--question4from nopay3Where nopay3.Week = '1'select *from Dependentscreate view dependentsview(empid, dependentname,birthday) asSelect *FROM DependentsSelect *from dependentsviewCreate view transcript(ssn, title, progcode, sdate,location) asSelect register.ssn, seminar.title, register.progcode, course.sdate, course.locationFrom register, seminar, courseSelect *from transcriptSelect *from transcriptWhere ssn='451-09-0982'create view seminar_summary--extraas select title, count(distinct course.progcode) as sessions,      Count (Register.ssn) as enrollments   FROM Seminar   Inner join Course on Seminar.semcode = Course.semcode   Left Outer Join Register On Course.progcode = Register.progcode   Group by titleSelect title, sessions, enrollmentsfrom seminar_summary--SUBQUERIES--using INSelect customer, saledatefrom mysaleswhere partnum in (select partnumfrom mydustwhere descrip = 'muffler' )Select id, absdatefrom absentwhere id IN(select id from Employeewhere zip like '631%')--single value subquerySelect partnum, pricefrom mydustwhere price >(Select AVG(Price)From Mydust)--Exercise 5Select *from EmployeeSelect *From StudentsSelect *from mysalesSelect partnum, descrip, automake--question1from MydustWHERE partnum in(select partnumfrom mysaleswhere customer = 'Joe''s Garage')select *from employeeselect *from absentSelectfrom EmployeeSelect absdate--question2from absentwhere id in(select idfrom employeewhere deptcode = 'MK')Select *from StudentsSelect *from registerselect ssn, firstname, lastname--question3from studentswhere ssn in(Select ssnfrom registerwhere progcode= 'A1010')--PARTII--part1--part2select *from mydustwhere price =(select MIN(price) From mydust)--part3select*from travelwhere miles =(select MIN(miles) from travel)--part4select partnum, quantity, price, price*quantity from mydustwhere Price*Quantity >(select AVG(Price*Quantity) FROM Mydust)--date dataselect *from mysalesinsert into mysales values('B9000',2,'WOR','2006-7-13')insert into mysales values('B9999',2,'WOR','2006-7-13 12:45')insert into mysales values('B3333',2,'WOR', 'july 13 06')select partnum, customer, convert(char(12),(saledate),1) from mysalesSelect *from mysaleswhere saledate between '2005-10-15' AND '2005-11-15'Select *from mysaleswhere saledate < '2005-11-15'select * from atranswhere invdate like '%am'select * from atranswhere invdate like 'feb % 2006 %'select * from atranswhere invdate like 'feb  % 2006 %'--2spaces before %select * from atranswhere convert(char(8), invdate,1) like '02/%/06'Select *--question1from Vanitywhere pubdate = '2002-10-21' Select *from Vanity where pubdate > '2002-12-31'Select *from Vanity where pubdate  between '2000-03-01' AND '2002-11-15'Select title, convert(CHAR(8), pubdate, 1)AS short_pubdate from VanitySelect titlefrom Vanitywhere pubdate like 'FEB %2004%'select * from vanity where pubdate like 'Feb %2004%'--part2select *from repsaleswhere saledate < '2005-08-20'select *from repsaleswhere amount > '$300.00' andwhere saledate like 'Sep %2005%' select * from repsales where saledate like '%pm'select count(*) from repsaleswhere saledate between '2005-08-15' and '2005-09-15 11:59pm'select * from repsales where datepart(dw, saledate) = 4select* from repsaleswhere datepart(dw, saledate) = 5 and salesrep_code = 'B707'--alter tablealter table mydustadd vendid char(8) nullselect * from mydustalter table mydust--to put a default value for new fieldadd default 'unknown' for vendidupdate mydust set vendid = default where vendid is nullalter table mydust alter column vendid char(8) not null --to force a value--check constraintalter table mysales add constraint chk_date check(saledate >= '1990-01-01')insert into mysales values('b9000', 4,'AH','1989-02-18')sp_help mysales